/* tslint:disable */
/* eslint-disable */
// Generated by Microsoft Kiota
// @ts-ignore
import { type AdditionalDataHolder, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export interface Argument extends AdditionalDataHolder, Parsable {
    /**
     * The commands property
     */
    commands?: Command[] | null;
    /**
     * The id property
     */
    id?: number | null;
    /**
     * The name property
     */
    name?: string | null;
    /**
     * The required property
     */
    required?: boolean | null;
}
export interface Command extends AdditionalDataHolder, Parsable {
    /**
     * The arguments property
     */
    arguments?: Argument[] | null;
    /**
     * The command property
     */
    command?: string | null;
    /**
     * The format property
     */
    format?: string | null;
    /**
     * The id property
     */
    id?: string | null;
    /**
     * The name property
     */
    name?: string | null;
    /**
     * The optional property
     */
    optional?: boolean | null;
    /**
     * The taskCommands property
     */
    taskCommands?: TaskCommand[] | null;
    /**
     * The wd property
     */
    wd?: string | null;
}
export interface CreateArgumentDto extends AdditionalDataHolder, Parsable {
    /**
     * The ID of the command this argument belongs to (optional).
     */
    commandId?: string | null;
    /**
     * The name of the argument.
     */
    name?: string | null;
    /**
     * Indicates if the argument is required.
     */
    required?: boolean | null;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Argument}
 */
// @ts-ignore
export function createArgumentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoArgument;
}
export interface CreateCommandDto extends AdditionalDataHolder, Parsable {
    /**
     * The list of arguments for the command.@type {CreateArgumentDto[]}
     */
    arguments?: CreateArgumentDto[] | null;
    /**
     * The command to be executed, for now including arguments@type {string}
     */
    command?: string | null;
    /**
     * The format for the command arguments.This is used to format the arguments when they are passed to the command.@type {string}@default '--{{name}}={{value}}'
     */
    format?: string | null;
    /**
     * The command to be executed, for now including arguments@type {string}
     */
    name?: string | null;
    /**
     * Optional flag to indicate if the command is optional, if so it will not block the task on fail.@type {boolean}@default false
     */
    optional?: boolean | null;
    /**
     * Optional task ID to associate the command with a specific task.@type {string}
     */
    taskId?: string | null;
    /**
     * The working directory for the command.@type {string}
     */
    wd?: string | null;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Command}
 */
// @ts-ignore
export function createCommandFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCommand;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CreateArgumentDto}
 */
// @ts-ignore
export function createCreateArgumentDtoFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCreateArgumentDto;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CreateCommandDto}
 */
// @ts-ignore
export function createCreateCommandDtoFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCreateCommandDto;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CreateTaskDto}
 */
// @ts-ignore
export function createCreateTaskDtoFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCreateTaskDto;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ExecuteTaskDto_commandArguments}
 */
// @ts-ignore
export function createExecuteTaskDto_commandArgumentsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoExecuteTaskDto_commandArguments;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ExecuteTaskDto}
 */
// @ts-ignore
export function createExecuteTaskDtoFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoExecuteTaskDto;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ExecuteTaskRunDto}
 */
// @ts-ignore
export function createExecuteTaskRunDtoFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoExecuteTaskRunDto;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {QueueTaskDto_commandArguments}
 */
// @ts-ignore
export function createQueueTaskDto_commandArgumentsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoQueueTaskDto_commandArguments;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {QueueTaskDto}
 */
// @ts-ignore
export function createQueueTaskDtoFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoQueueTaskDto;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TaskCommand}
 */
// @ts-ignore
export function createTaskCommandFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTaskCommand;
}
export interface CreateTaskDto extends AdditionalDataHolder, Parsable {
    /**
     * The list of commands associated with the task@type {CommandDto[]}
     */
    commands?: CreateCommandDto[] | null;
    /**
     * An optional description of the task.@type {string}
     */
    description?: string | null;
    /**
     * The name of the task.@type {string}
     */
    name?: string | null;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Task}
 */
// @ts-ignore
export function createTaskFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTask;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TaskResult}
 */
// @ts-ignore
export function createTaskResultFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTaskResult;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UpdateArgumentDto}
 */
// @ts-ignore
export function createUpdateArgumentDtoFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUpdateArgumentDto;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UpdateCommandDto}
 */
// @ts-ignore
export function createUpdateCommandDtoFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUpdateCommandDto;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UpdateTaskDto}
 */
// @ts-ignore
export function createUpdateTaskDtoFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUpdateTaskDto;
}
/**
 * The deserialization information for the current model
 * @param Argument The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoArgument(argument: Partial<Argument> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "commands": n => { argument.commands = n.getCollectionOfObjectValues<Command>(createCommandFromDiscriminatorValue); },
        "id": n => { argument.id = n.getNumberValue(); },
        "name": n => { argument.name = n.getStringValue(); },
        "required": n => { argument.required = n.getBooleanValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param Command The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoCommand(command: Partial<Command> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "arguments": n => { command.arguments = n.getCollectionOfObjectValues<Argument>(createArgumentFromDiscriminatorValue); },
        "command": n => { command.command = n.getStringValue(); },
        "format": n => { command.format = n.getStringValue(); },
        "id": n => { command.id = n.getStringValue(); },
        "name": n => { command.name = n.getStringValue(); },
        "optional": n => { command.optional = n.getBooleanValue(); },
        "taskCommands": n => { command.taskCommands = n.getCollectionOfObjectValues<TaskCommand>(createTaskCommandFromDiscriminatorValue); },
        "wd": n => { command.wd = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param CreateArgumentDto The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoCreateArgumentDto(createArgumentDto: Partial<CreateArgumentDto> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "commandId": n => { createArgumentDto.commandId = n.getStringValue(); },
        "name": n => { createArgumentDto.name = n.getStringValue(); },
        "required": n => { createArgumentDto.required = n.getBooleanValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param CreateCommandDto The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoCreateCommandDto(createCommandDto: Partial<CreateCommandDto> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "arguments": n => { createCommandDto.arguments = n.getCollectionOfObjectValues<CreateArgumentDto>(createCreateArgumentDtoFromDiscriminatorValue); },
        "command": n => { createCommandDto.command = n.getStringValue(); },
        "format": n => { createCommandDto.format = n.getStringValue() ?? "--{{name}}={{value}}"; },
        "name": n => { createCommandDto.name = n.getStringValue(); },
        "optional": n => { createCommandDto.optional = n.getBooleanValue(); },
        "taskId": n => { createCommandDto.taskId = n.getStringValue(); },
        "wd": n => { createCommandDto.wd = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param CreateTaskDto The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoCreateTaskDto(createTaskDto: Partial<CreateTaskDto> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "commands": n => { createTaskDto.commands = n.getCollectionOfObjectValues<CreateCommandDto>(createCreateCommandDtoFromDiscriminatorValue); },
        "description": n => { createTaskDto.description = n.getStringValue(); },
        "name": n => { createTaskDto.name = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param ExecuteTaskDto The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoExecuteTaskDto(executeTaskDto: Partial<ExecuteTaskDto> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "commandArguments": n => { executeTaskDto.commandArguments = n.getObjectValue<ExecuteTaskDto_commandArguments>(createExecuteTaskDto_commandArgumentsFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param ExecuteTaskDto_commandArguments The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoExecuteTaskDto_commandArguments(executeTaskDto_commandArguments: Partial<ExecuteTaskDto_commandArguments> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
    }
}
/**
 * The deserialization information for the current model
 * @param ExecuteTaskRunDto The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoExecuteTaskRunDto(executeTaskRunDto: Partial<ExecuteTaskRunDto> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "queued": n => { executeTaskRunDto.queued = n.getBooleanValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param QueueTaskDto The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoQueueTaskDto(queueTaskDto: Partial<QueueTaskDto> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "commandArguments": n => { queueTaskDto.commandArguments = n.getObjectValue<QueueTaskDto_commandArguments>(createQueueTaskDto_commandArgumentsFromDiscriminatorValue); },
        "priority": n => { queueTaskDto.priority = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param QueueTaskDto_commandArguments The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoQueueTaskDto_commandArguments(queueTaskDto_commandArguments: Partial<QueueTaskDto_commandArguments> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
    }
}
/**
 * The deserialization information for the current model
 * @param Task The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTask(task: Partial<Task> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "createdAt": n => { task.createdAt = n.getDateValue(); },
        "description": n => { task.description = n.getStringValue(); },
        "id": n => { task.id = n.getStringValue(); },
        "name": n => { task.name = n.getStringValue(); },
        "queued": n => { task.queued = n.getBooleanValue(); },
        "results": n => { task.results = n.getCollectionOfObjectValues<TaskResult>(createTaskResultFromDiscriminatorValue); },
        "taskCommands": n => { task.taskCommands = n.getCollectionOfObjectValues<TaskCommand>(createTaskCommandFromDiscriminatorValue); },
        "updatedAt": n => { task.updatedAt = n.getDateValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param TaskCommand The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTaskCommand(taskCommand: Partial<TaskCommand> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "command": n => { taskCommand.command = n.getObjectValue<Command>(createCommandFromDiscriminatorValue); },
        "createdAt": n => { taskCommand.createdAt = n.getDateValue(); },
        "executionOrder": n => { taskCommand.executionOrder = n.getNumberValue(); },
        "id": n => { taskCommand.id = n.getStringValue(); },
        "task": n => { taskCommand.task = n.getObjectValue<Task>(createTaskFromDiscriminatorValue); },
        "updatedAt": n => { taskCommand.updatedAt = n.getDateValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param TaskResult The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTaskResult(taskResult: Partial<TaskResult> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "createdAt": n => { taskResult.createdAt = n.getDateValue(); },
        "error": n => { taskResult.errorEscaped = n.getStringValue(); },
        "id": n => { taskResult.id = n.getStringValue(); },
        "output": n => { taskResult.output = n.getStringValue(); },
        "success": n => { taskResult.success = n.getBooleanValue(); },
        "task": n => { taskResult.task = n.getObjectValue<Task>(createTaskFromDiscriminatorValue); },
        "updatedAt": n => { taskResult.updatedAt = n.getDateValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param UpdateArgumentDto The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoUpdateArgumentDto(updateArgumentDto: Partial<UpdateArgumentDto> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "name": n => { updateArgumentDto.name = n.getStringValue(); },
        "required": n => { updateArgumentDto.required = n.getBooleanValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param UpdateCommandDto The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoUpdateCommandDto(updateCommandDto: Partial<UpdateCommandDto> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "arguments": n => { updateCommandDto.arguments = n.getCollectionOfObjectValues<Argument>(createArgumentFromDiscriminatorValue); },
        "command": n => { updateCommandDto.command = n.getStringValue(); },
        "format": n => { updateCommandDto.format = n.getStringValue() ?? "--{{name}}={{value}}"; },
        "name": n => { updateCommandDto.name = n.getStringValue(); },
        "optional": n => { updateCommandDto.optional = n.getBooleanValue(); },
        "wd": n => { updateCommandDto.wd = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param UpdateTaskDto The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoUpdateTaskDto(updateTaskDto: Partial<UpdateTaskDto> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "commands": n => { updateTaskDto.commands = n.getCollectionOfObjectValues<Command>(createCommandFromDiscriminatorValue); },
        "description": n => { updateTaskDto.description = n.getStringValue(); },
        "name": n => { updateTaskDto.name = n.getStringValue(); },
    }
}
export interface ExecuteTaskDto extends AdditionalDataHolder, Parsable {
    /**
     * Arguments per named command (per named argument)
     */
    commandArguments?: ExecuteTaskDto_commandArguments | null;
}
/**
 * Arguments per named command (per named argument)
 */
export interface ExecuteTaskDto_commandArguments extends AdditionalDataHolder, Parsable {
}
export interface ExecuteTaskRunDto extends AdditionalDataHolder, Parsable {
    /**
     * Whether the task should be queued or executed immediately.@type {boolean}@default false
     */
    queued?: boolean | null;
}
export interface QueueTaskDto extends AdditionalDataHolder, Parsable {
    /**
     * Arguments per named command (per named argument)
     */
    commandArguments?: QueueTaskDto_commandArguments | null;
    /**
     * Arguments per named command (per named argument)
     */
    priority?: number | null;
}
/**
 * Arguments per named command (per named argument)
 */
export interface QueueTaskDto_commandArguments extends AdditionalDataHolder, Parsable {
}
/**
 * Serializes information the current object
 * @param Argument The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeArgument(writer: SerializationWriter, argument: Partial<Argument> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!argument || isSerializingDerivedType) { return; }
    writer.writeCollectionOfObjectValues<Command>("commands", argument.commands, serializeCommand);
    writer.writeNumberValue("id", argument.id);
    writer.writeStringValue("name", argument.name);
    writer.writeBooleanValue("required", argument.required);
    writer.writeAdditionalData(argument.additionalData);
}
/**
 * Serializes information the current object
 * @param Command The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeCommand(writer: SerializationWriter, command: Partial<Command> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!command || isSerializingDerivedType) { return; }
    writer.writeCollectionOfObjectValues<Argument>("arguments", command.arguments, serializeArgument);
    writer.writeStringValue("command", command.command);
    writer.writeStringValue("format", command.format);
    writer.writeStringValue("id", command.id);
    writer.writeStringValue("name", command.name);
    writer.writeBooleanValue("optional", command.optional);
    writer.writeCollectionOfObjectValues<TaskCommand>("taskCommands", command.taskCommands, serializeTaskCommand);
    writer.writeStringValue("wd", command.wd);
    writer.writeAdditionalData(command.additionalData);
}
/**
 * Serializes information the current object
 * @param CreateArgumentDto The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeCreateArgumentDto(writer: SerializationWriter, createArgumentDto: Partial<CreateArgumentDto> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!createArgumentDto || isSerializingDerivedType) { return; }
    writer.writeStringValue("commandId", createArgumentDto.commandId);
    writer.writeStringValue("name", createArgumentDto.name);
    writer.writeBooleanValue("required", createArgumentDto.required);
    writer.writeAdditionalData(createArgumentDto.additionalData);
}
/**
 * Serializes information the current object
 * @param CreateCommandDto The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeCreateCommandDto(writer: SerializationWriter, createCommandDto: Partial<CreateCommandDto> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!createCommandDto || isSerializingDerivedType) { return; }
    writer.writeCollectionOfObjectValues<CreateArgumentDto>("arguments", createCommandDto.arguments, serializeCreateArgumentDto);
    writer.writeStringValue("command", createCommandDto.command);
    writer.writeStringValue("format", createCommandDto.format ?? "--{{name}}={{value}}");
    writer.writeStringValue("name", createCommandDto.name);
    writer.writeBooleanValue("optional", createCommandDto.optional);
    writer.writeStringValue("taskId", createCommandDto.taskId);
    writer.writeStringValue("wd", createCommandDto.wd);
    writer.writeAdditionalData(createCommandDto.additionalData);
}
/**
 * Serializes information the current object
 * @param CreateTaskDto The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeCreateTaskDto(writer: SerializationWriter, createTaskDto: Partial<CreateTaskDto> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!createTaskDto || isSerializingDerivedType) { return; }
    writer.writeCollectionOfObjectValues<CreateCommandDto>("commands", createTaskDto.commands, serializeCreateCommandDto);
    writer.writeStringValue("description", createTaskDto.description);
    writer.writeStringValue("name", createTaskDto.name);
    writer.writeAdditionalData(createTaskDto.additionalData);
}
/**
 * Serializes information the current object
 * @param ExecuteTaskDto The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeExecuteTaskDto(writer: SerializationWriter, executeTaskDto: Partial<ExecuteTaskDto> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!executeTaskDto || isSerializingDerivedType) { return; }
    writer.writeObjectValue<ExecuteTaskDto_commandArguments>("commandArguments", executeTaskDto.commandArguments, serializeExecuteTaskDto_commandArguments);
    writer.writeAdditionalData(executeTaskDto.additionalData);
}
/**
 * Serializes information the current object
 * @param ExecuteTaskDto_commandArguments The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeExecuteTaskDto_commandArguments(writer: SerializationWriter, executeTaskDto_commandArguments: Partial<ExecuteTaskDto_commandArguments> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!executeTaskDto_commandArguments || isSerializingDerivedType) { return; }
    writer.writeAdditionalData(executeTaskDto_commandArguments.additionalData);
}
/**
 * Serializes information the current object
 * @param ExecuteTaskRunDto The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeExecuteTaskRunDto(writer: SerializationWriter, executeTaskRunDto: Partial<ExecuteTaskRunDto> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!executeTaskRunDto || isSerializingDerivedType) { return; }
    writer.writeBooleanValue("queued", executeTaskRunDto.queued);
    writer.writeAdditionalData(executeTaskRunDto.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param QueueTaskDto The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeQueueTaskDto(writer: SerializationWriter, queueTaskDto: Partial<QueueTaskDto> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!queueTaskDto || isSerializingDerivedType) { return; }
    writer.writeObjectValue<QueueTaskDto_commandArguments>("commandArguments", queueTaskDto.commandArguments, serializeQueueTaskDto_commandArguments);
    writer.writeNumberValue("priority", queueTaskDto.priority);
    writer.writeAdditionalData(queueTaskDto.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param QueueTaskDto_commandArguments The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeQueueTaskDto_commandArguments(writer: SerializationWriter, queueTaskDto_commandArguments: Partial<QueueTaskDto_commandArguments> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!queueTaskDto_commandArguments || isSerializingDerivedType) { return; }
    writer.writeAdditionalData(queueTaskDto_commandArguments.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param Task The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTask(writer: SerializationWriter, task: Partial<Task> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!task || isSerializingDerivedType) { return; }
    writer.writeDateValue("createdAt", task.createdAt);
    writer.writeStringValue("description", task.description);
    writer.writeStringValue("id", task.id);
    writer.writeStringValue("name", task.name);
    writer.writeBooleanValue("queued", task.queued);
    writer.writeCollectionOfObjectValues<TaskResult>("results", task.results, serializeTaskResult);
    writer.writeCollectionOfObjectValues<TaskCommand>("taskCommands", task.taskCommands, serializeTaskCommand);
    writer.writeDateValue("updatedAt", task.updatedAt);
    writer.writeAdditionalData(task.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param TaskCommand The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTaskCommand(writer: SerializationWriter, taskCommand: Partial<TaskCommand> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!taskCommand || isSerializingDerivedType) { return; }
    writer.writeObjectValue<Command>("command", taskCommand.command, serializeCommand);
    writer.writeDateValue("createdAt", taskCommand.createdAt);
    writer.writeNumberValue("executionOrder", taskCommand.executionOrder);
    writer.writeStringValue("id", taskCommand.id);
    writer.writeObjectValue<Task>("task", taskCommand.task, serializeTask);
    writer.writeDateValue("updatedAt", taskCommand.updatedAt);
    writer.writeAdditionalData(taskCommand.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param TaskResult The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTaskResult(writer: SerializationWriter, taskResult: Partial<TaskResult> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!taskResult || isSerializingDerivedType) { return; }
    writer.writeDateValue("createdAt", taskResult.createdAt);
    writer.writeStringValue("error", taskResult.errorEscaped);
    writer.writeStringValue("id", taskResult.id);
    writer.writeStringValue("output", taskResult.output);
    writer.writeBooleanValue("success", taskResult.success);
    writer.writeObjectValue<Task>("task", taskResult.task, serializeTask);
    writer.writeDateValue("updatedAt", taskResult.updatedAt);
    writer.writeAdditionalData(taskResult.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param UpdateArgumentDto The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeUpdateArgumentDto(writer: SerializationWriter, updateArgumentDto: Partial<UpdateArgumentDto> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!updateArgumentDto || isSerializingDerivedType) { return; }
    writer.writeStringValue("name", updateArgumentDto.name);
    writer.writeBooleanValue("required", updateArgumentDto.required);
    writer.writeAdditionalData(updateArgumentDto.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param UpdateCommandDto The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeUpdateCommandDto(writer: SerializationWriter, updateCommandDto: Partial<UpdateCommandDto> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!updateCommandDto || isSerializingDerivedType) { return; }
    writer.writeCollectionOfObjectValues<Argument>("arguments", updateCommandDto.arguments, serializeArgument);
    writer.writeStringValue("command", updateCommandDto.command);
    writer.writeStringValue("format", updateCommandDto.format ?? "--{{name}}={{value}}");
    writer.writeStringValue("name", updateCommandDto.name);
    writer.writeBooleanValue("optional", updateCommandDto.optional);
    writer.writeStringValue("wd", updateCommandDto.wd);
    writer.writeAdditionalData(updateCommandDto.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param UpdateTaskDto The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeUpdateTaskDto(writer: SerializationWriter, updateTaskDto: Partial<UpdateTaskDto> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!updateTaskDto || isSerializingDerivedType) { return; }
    writer.writeCollectionOfObjectValues<Command>("commands", updateTaskDto.commands, serializeCommand);
    writer.writeStringValue("description", updateTaskDto.description);
    writer.writeStringValue("name", updateTaskDto.name);
    writer.writeAdditionalData(updateTaskDto.additionalData);
}
export interface Task extends AdditionalDataHolder, Parsable {
    /**
     * The createdAt property
     */
    createdAt?: Date | null;
    /**
     * The description property
     */
    description?: string | null;
    /**
     * The id property
     */
    id?: string | null;
    /**
     * The name property
     */
    name?: string | null;
    /**
     * The queued property
     */
    queued?: boolean | null;
    /**
     * The results property
     */
    results?: TaskResult[] | null;
    /**
     * The taskCommands property
     */
    taskCommands?: TaskCommand[] | null;
    /**
     * The updatedAt property
     */
    updatedAt?: Date | null;
}
export interface TaskCommand extends AdditionalDataHolder, Parsable {
    /**
     * The command property
     */
    command?: Command | null;
    /**
     * The createdAt property
     */
    createdAt?: Date | null;
    /**
     * The executionOrder property
     */
    executionOrder?: number | null;
    /**
     * The id property
     */
    id?: string | null;
    /**
     * The task property
     */
    task?: Task | null;
    /**
     * The updatedAt property
     */
    updatedAt?: Date | null;
}
export interface TaskResult extends AdditionalDataHolder, Parsable {
    /**
     * The createdAt property
     */
    createdAt?: Date | null;
    /**
     * The error property
     */
    errorEscaped?: string | null;
    /**
     * The id property
     */
    id?: string | null;
    /**
     * The output property
     */
    output?: string | null;
    /**
     * The success property
     */
    success?: boolean | null;
    /**
     * The task property
     */
    task?: Task | null;
    /**
     * The updatedAt property
     */
    updatedAt?: Date | null;
}
export interface UpdateArgumentDto extends AdditionalDataHolder, Parsable {
    /**
     * The name of the argument.
     */
    name?: string | null;
    /**
     * Indicates if the argument is required.
     */
    required?: boolean | null;
}
export interface UpdateCommandDto extends AdditionalDataHolder, Parsable {
    /**
     * The list of arguments for the command.@type {Argument[]}
     */
    arguments?: Argument[] | null;
    /**
     * The command to be executed, for now including arguments@type {string}
     */
    command?: string | null;
    /**
     * The format for the command arguments.This is used to format the arguments when they are passed to the command.@type {string}@default '--{{name}}={{value}}'
     */
    format?: string | null;
    /**
     * The command to be executed, for now including arguments@type {string}
     */
    name?: string | null;
    /**
     * Optional flag to indicate if the command is optional, if so it will not block the task on fail.@type {boolean}@default false
     */
    optional?: boolean | null;
    /**
     * The working directory for the command.@type {string}
     */
    wd?: string | null;
}
export interface UpdateTaskDto extends AdditionalDataHolder, Parsable {
    /**
     * The list of commands associated with the task@type {CommandDto[]}
     */
    commands?: Command[] | null;
    /**
     * An optional description of the task.@type {string}
     */
    description?: string | null;
    /**
     * The name of the task.@type {string}
     */
    name?: string | null;
}
/* tslint:enable */
/* eslint-enable */
